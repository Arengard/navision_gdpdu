---
phase: 02-xml-parser
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [src/gdpdu_parser.hpp, src/gdpdu_parser.cpp, src/CMakeLists.txt]
autonomous: true

must_haves:
  truths:
    - "Parser reads index.xml file from given directory path"
    - "Parser extracts all Table definitions from Media element"
    - "Column names are extracted from Name elements in VariableColumn/VariablePrimaryKey"
    - "Column types are correctly identified (AlphaNumeric, Numeric with Accuracy, Date)"
    - "Primary keys are identified including composite keys (multiple VariablePrimaryKey)"
    - "Data file URLs are extracted from URL elements"
  artifacts:
    - path: "src/gdpdu_parser.hpp"
      provides: "XML parser interface for GDPdU index.xml"
      min_lines: 20
      contains: "parse_index_xml"
    - path: "src/gdpdu_parser.cpp"
      provides: "XML parser implementation using pugixml"
      min_lines: 80
      contains: "pugixml"
  key_links:
    - from: "src/gdpdu_parser.cpp"
      to: "src/gdpdu_schema.hpp"
      via: "populates TableDef and ColumnDef structures"
      pattern: "#include.*gdpdu_schema"
    - from: "src/gdpdu_parser.cpp"
      to: "pugixml"
      via: "XML DOM parsing"
      pattern: "pugi::xml_document"
---

<objective>
Implement the XML parser that reads GDPdU index.xml and extracts schema definitions.

Purpose: Parse the index.xml file using pugixml and populate the GdpduSchema structure with all table/column metadata â€” this is the core of Phase 2.

Output: Working parser that can read any valid GDPdU index.xml and return structured schema data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Prior plan output (schema structures):
@src/gdpdu_schema.hpp

Sample XML for reference:
@Gdpdu Data/index.xml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GDPdU XML parser</name>
  <files>src/gdpdu_parser.hpp, src/gdpdu_parser.cpp</files>
  <action>
Create the XML parser that reads index.xml and populates GdpduSchema.

**src/gdpdu_parser.hpp**:

```cpp
#pragma once

#include "gdpdu_schema.hpp"
#include <string>

namespace duckdb {

// Parse GDPdU index.xml from a directory path
// Returns GdpduSchema with all table definitions
// Throws std::runtime_error on parse failure
GdpduSchema parse_index_xml(const std::string& directory_path);

} // namespace duckdb
```

**src/gdpdu_parser.cpp**:

1. Include headers:
   - `"gdpdu_parser.hpp"`
   - `"gdpdu_schema.hpp"`
   - `<pugixml.hpp>`
   - `<stdexcept>`
   - `<filesystem>` (or handle path joining manually for C++11)

2. Implement `parse_index_xml(directory_path)`:

   a. **Build index.xml path**:
      - Join directory_path with "index.xml"
      - Handle both forward and backslash separators (Windows compatibility)
   
   b. **Load XML document**:
      ```cpp
      pugi::xml_document doc;
      pugi::xml_parse_result result = doc.load_file(index_path.c_str());
      if (!result) {
          throw std::runtime_error("Failed to parse index.xml: " + std::string(result.description()));
      }
      ```
   
   c. **Navigate to DataSet/Media**:
      ```cpp
      pugi::xml_node dataset = doc.child("DataSet");
      pugi::xml_node media = dataset.child("Media");
      ```
   
   d. **Extract Media name**:
      ```cpp
      schema.media_name = media.child_value("Name");
      ```
   
   e. **Iterate over Table elements**:
      ```cpp
      for (pugi::xml_node table_node : media.children("Table")) {
          TableDef table = parse_table(table_node);
          schema.tables.push_back(table);
      }
      ```

3. Implement helper function `parse_table(xml_node)`:

   a. Extract basic metadata:
      - `table.url = table_node.child_value("URL")`
      - `table.name = table_node.child_value("Name")`
      - `table.description = table_node.child_value("Description")`
      - `table.is_utf8 = !table_node.child("UTF8").empty()`
   
   b. Extract locale settings:
      - `table.decimal_symbol = ','` (default)
      - `table.digit_grouping = '.'` (default)
      - If DecimalSymbol element exists, take first char
      - If DigitGroupingSymbol element exists, take first char
   
   c. Navigate to VariableLength:
      ```cpp
      pugi::xml_node var_length = table_node.child("VariableLength");
      ```
   
   d. Parse VariablePrimaryKey elements (in order):
      ```cpp
      for (pugi::xml_node pk : var_length.children("VariablePrimaryKey")) {
          ColumnDef col = parse_column(pk, true);  // is_primary_key = true
          table.columns.push_back(col);
          table.primary_key_columns.push_back(col.name);
      }
      ```
   
   e. Parse VariableColumn elements (in order):
      ```cpp
      for (pugi::xml_node vc : var_length.children("VariableColumn")) {
          ColumnDef col = parse_column(vc, false);  // is_primary_key = false
          table.columns.push_back(col);
      }
      ```

4. Implement helper function `parse_column(xml_node, is_pk)`:

   a. Extract name:
      ```cpp
      col.name = node.child_value("Name");
      col.is_primary_key = is_pk;
      ```
   
   b. Determine type:
      ```cpp
      if (!node.child("AlphaNumeric").empty()) {
          col.type = GdpduType::AlphaNumeric;
          col.precision = 0;
      } else if (!node.child("Numeric").empty()) {
          col.type = GdpduType::Numeric;
          // Check for Accuracy sub-element
          pugi::xml_node numeric = node.child("Numeric");
          pugi::xml_node accuracy = numeric.child("Accuracy");
          if (!accuracy.empty()) {
              col.precision = std::stoi(accuracy.child_value());
          } else {
              col.precision = 0;  // Integer
          }
      } else if (!node.child("Date").empty()) {
          col.type = GdpduType::Date;
          col.precision = 0;
      } else {
          // Default to AlphaNumeric if type not found
          col.type = GdpduType::AlphaNumeric;
          col.precision = 0;
      }
      ```

**Important Notes**:
- pugixml child_value() returns empty string if element not found (safe)
- Keep columns in document order (PK columns first, then regular columns)
- Handle edge cases: empty tables, missing optional elements
  </action>
  <verify>cmake --build build compiles without errors; include parser header in extension to verify linkage</verify>
  <done>Parser compiles and can be called with a directory path</done>
</task>

<task type="auto">
  <name>Task 2: Update CMake and test parser with sample data</name>
  <files>src/CMakeLists.txt, src/gdpdu_extension.cpp</files>
  <action>
Update CMake to include parser source and add a basic test in the extension.

**src/CMakeLists.txt**:
Add gdpdu_parser.cpp to the extension sources list.

**src/gdpdu_extension.cpp**:
Add a temporary test call to verify parser works:

1. Include the parser header:
   ```cpp
   #include "gdpdu_parser.hpp"
   ```

2. In the Load function (temporarily, for testing):
   ```cpp
   void GdpduExtension::Load(DuckDB &db) {
       std::cout << "GDPdU extension loaded successfully!" << std::endl;
       
       // Temporary test - remove after verification
       // Uncomment to test with sample data:
       // try {
       //     auto schema = parse_index_xml("Gdpdu Data");
       //     std::cout << "Parsed " << schema.tables.size() << " tables from index.xml" << std::endl;
       //     for (const auto& table : schema.tables) {
       //         std::cout << "  Table: " << table.name << " (" << table.columns.size() << " columns)" << std::endl;
       //     }
       // } catch (const std::exception& e) {
       //     std::cout << "Parse error: " << e.what() << std::endl;
       // }
   }
   ```

**Build and verify**:
1. Run `cmake --build build --config Release`
2. If sample data is available, temporarily uncomment the test code
3. Run extension and verify output shows parsed tables

Expected output with sample data:
```
Parsed 17 tables from index.xml
  Table: LandRegion (3 columns)
  Table: Sachkonto (7 columns)
  Table: Sachposten (24 columns)
  ...
```
  </action>
  <verify>cmake --build build --config Release succeeds; extension compiles with parser included</verify>
  <done>Parser integrated into extension; ready for Phase 3 table creation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] src/gdpdu_parser.hpp exists with parse_index_xml declaration
- [ ] src/gdpdu_parser.cpp exists with full implementation
- [ ] cmake --build build completes without errors
- [ ] Parser correctly handles sample index.xml structure
- [ ] Primary keys (including composite) are identified
- [ ] Column types and precision are extracted
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Parser reads index.xml and extracts all table definitions
- Column names, types, precision, and primary keys are correct
- Data file URLs are extracted
- Ready for Phase 3 (table creation)
</success_criteria>

<output>
After completion, create `.planning/phases/02-xml-parser/02-02-SUMMARY.md`
</output>
