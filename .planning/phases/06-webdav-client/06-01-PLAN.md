---
phase: 06-webdav-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/include/webdav_client.hpp
  - src/webdav_client.cpp
  - src/CMakeLists.txt
autonomous: true
must_haves:
  truths:
    - "Extension can authenticate to Nextcloud WebDAV with username and password (HTTP Basic Auth)"
    - "Extension lists all .zip files from a specified WebDAV folder URL via PROPFIND"
    - "Extension downloads zip files to a temporary directory via HTTP GET"
    - "Network errors (auth failure, connection refused, timeout, 404) are caught and returned as error strings, not exceptions"
  artifacts:
    - path: "src/include/webdav_client.hpp"
      provides: "WebDAV client interface"
      contains: "WebDavClient"
    - path: "src/webdav_client.cpp"
      provides: "WebDAV client implementation using cpp-httplib"
      contains: "PROPFIND"
    - path: "src/CMakeLists.txt"
      provides: "Build integration for webdav_client.cpp"
      contains: "webdav_client.cpp"
  key_links:
    - from: "src/webdav_client.cpp"
      to: "duckdb_httplib::Client"
      via: "direct httplib usage for PROPFIND and GET"
      pattern: "duckdb_httplib::Client"
    - from: "src/webdav_client.cpp"
      to: "pugixml"
      via: "parsing PROPFIND XML response"
      pattern: "pugi::xml_document"
---

<objective>
Implement a WebDAV client module that connects to Nextcloud, lists .zip files in a folder, and downloads them to a temporary directory.

Purpose: This is the networking foundation for the v1.1 Nextcloud batch import feature. Phases 7 and 8 will use this module to fetch zip files before extracting and importing GDPdU data.

Output: `webdav_client.hpp` and `webdav_client.cpp` — a self-contained WebDAV client module integrated into the build.
</objective>

<execution_context>
@C:/Users/Ramon.Ljevo/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Ramon.Ljevo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md

Key codebase context:
- DuckDB v1.4.4 bundles cpp-httplib as `duckdb_httplib` in `third_party/httplib/httplib.hpp`
- DuckDB's `HTTPClient` wrapper (in `duckdb/common/http_util.hpp`) only supports GET/PUT/HEAD/DELETE/POST — NOT PROPFIND
- Therefore: use `duckdb_httplib::Client` directly (it has a generic `send(Request)` method that accepts any HTTP method)
- pugixml is already a project dependency (used for index.xml parsing) — reuse it to parse PROPFIND XML responses
- Build uses FetchContent for dependencies; src/CMakeLists.txt calls `build_static_extension` and `build_loadable_extension`
- Existing code pattern: all source in `src/`, headers in `src/include/`, one .hpp + one .cpp per module
- Namespace: `duckdb` (all extension code lives in this namespace)

WebDAV protocol notes:
- Nextcloud WebDAV endpoint: `https://{host}/remote.php/dav/files/{username}/{path}`
- Authentication: HTTP Basic Auth (base64-encoded "username:password" in Authorization header)
- Directory listing: PROPFIND request with `Depth: 1` header, body is optional (or minimal XML)
- PROPFIND response: XML with `<d:multistatus>` containing `<d:response>` elements, each with `<d:href>` for file path
- File download: standard HTTP GET on the file URL
- Content-Type for PROPFIND body: `application/xml`

@src/CMakeLists.txt
@src/include/gdpdu_importer.hpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebDAV client with authentication and directory listing</name>
  <files>
    src/include/webdav_client.hpp
    src/webdav_client.cpp
  </files>
  <action>
Create the WebDAV client module with two capabilities: authentication and directory listing.

**Header file (`src/include/webdav_client.hpp`):**

Define within `namespace duckdb`:

```cpp
struct WebDavFile {
    std::string name;      // filename (e.g. "export2024.zip")
    std::string href;      // full path from PROPFIND response
    bool is_collection;    // true if directory
};

struct WebDavResult {
    bool success;
    std::string error_message;  // empty on success
    std::vector<WebDavFile> files;
};

struct WebDavDownloadResult {
    bool success;
    std::string error_message;
    std::string local_path;     // path to downloaded file
};

class WebDavClient {
public:
    // Construct with Nextcloud base URL (e.g. "https://cloud.example.com/remote.php/dav/files/user/exports/")
    // and credentials for HTTP Basic Auth
    WebDavClient(const std::string& base_url, const std::string& username, const std::string& password);

    // List all files in the WebDAV folder. Returns only .zip files if filter_zips=true.
    WebDavResult list_files(bool filter_zips = true);

    // Download a single file to the specified local directory. Returns path to downloaded file.
    WebDavDownloadResult download_file(const std::string& href, const std::string& local_dir);

private:
    std::string base_url_;
    std::string username_;
    std::string password_;
    std::string proto_host_port_;  // e.g. "https://cloud.example.com"
    std::string base_path_;        // e.g. "/remote.php/dav/files/user/exports/"

    std::string make_auth_header() const;
    void parse_url();
};
```

**Implementation file (`src/webdav_client.cpp`):**

1. **Include httplib directly:** `#include "httplib.hpp"` (DuckDB bundles it and makes it available as `duckdb_httplib`)
2. **Include pugixml:** `#include "pugixml.hpp"` for parsing PROPFIND XML responses

3. **`parse_url()`**: Split `base_url_` into `proto_host_port_` and `base_path_` components. Handle both http and https URLs. Ensure `base_path_` ends with `/`.

4. **`make_auth_header()`**: Implement base64 encoding for HTTP Basic Auth. DuckDB's internal `Base64` utility may not be accessible, so implement a simple base64 encoder (standard 64-char table, padding with `=`). Return `"Basic " + base64(username + ":" + password)`.

5. **`list_files()`**:
   - Create `duckdb_httplib::Client` with `proto_host_port_`
   - Configure SSL verification: `client.enable_server_certificate_verification(false)` (common for internal Nextcloud instances with self-signed certs)
   - Set timeouts: 30 seconds for connection, read, write
   - Build a PROPFIND request:
     ```
     duckdb_httplib::Request req;
     req.method = "PROPFIND";
     req.path = base_path_;
     req.set_header("Authorization", make_auth_header());
     req.set_header("Depth", "1");
     req.set_header("Content-Type", "application/xml");
     req.body = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
                "<d:propfind xmlns:d=\"DAV:\">"
                "<d:prop><d:resourcetype/></d:prop>"
                "</d:propfind>";
     ```
   - Send via `client.send(req)` — this is the generic method that supports any HTTP method
   - Check for errors: connection failure, non-207 status (207 Multi-Status is the expected PROPFIND response)
   - On auth failure (401), return `WebDavResult{false, "Authentication failed: check username and password", {}}`
   - On connection error, return descriptive message including the URL attempted
   - Parse the 207 XML response body with pugixml:
     - Root element is `<d:multistatus>` (namespace `DAV:`)
     - Each `<d:response>` has a `<d:href>` child with the file/folder path
     - Each `<d:response>` has `<d:propstat>/<d:prop>/<d:resourcetype>` — if it contains `<d:collection/>`, it's a directory
     - Use pugixml namespace-aware traversal OR simple element name matching (pugixml handles namespace prefixes as part of element names, so look for elements ending in `:response`, `:href`, `:collection` etc.)
     - IMPORTANT: pugixml does not handle XML namespaces natively. The element names will include the prefix as written by the server (e.g., `d:response` or `D:response`). Parse by checking local name after the colon, or try both common prefixes.
   - For each non-collection response, extract filename from the href (last path component after URL-decoding)
   - If `filter_zips` is true, only include files where name ends with `.zip` (case-insensitive check)
   - Return `WebDavResult{true, "", files_vector}`

**Error handling approach:** Never throw exceptions from WebDavClient methods. Always return result structs with success/error_message. The caller (Phase 8's batch import function) will use these to report errors in the result set.

**Important implementation notes:**
- The PROPFIND response XML uses DAV: namespace. Nextcloud typically uses `d:` prefix but this is not guaranteed. Parse flexibly.
- The first `<d:response>` in a PROPFIND result is typically the folder itself — skip it (it matches `base_path_`).
- URL-decode the href values (at minimum handle `%20` for spaces, `%C3%xx` for UTF-8 chars). A simple percent-decode function is sufficient.
  </action>
  <verify>
The code compiles without errors. Verify by checking that the header defines WebDavClient, WebDavResult, WebDavFile structs, and the implementation includes PROPFIND request construction and XML response parsing.
  </verify>
  <done>
`webdav_client.hpp` defines WebDavClient class with list_files() and download_file() methods. `webdav_client.cpp` implements PROPFIND-based directory listing with HTTP Basic Auth, pugixml-based response parsing, and flexible namespace handling. Error conditions (auth failure, connection error, parse error) return descriptive error messages in result structs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement file download and integrate into build</name>
  <files>
    src/webdav_client.cpp
    src/include/webdav_client.hpp
    src/CMakeLists.txt
  </files>
  <action>
Complete the WebDAV client by implementing file download and integrating into the build system.

**1. Implement `download_file()` in `webdav_client.cpp`:**

- Takes `href` (the path from PROPFIND response) and `local_dir` (temp directory path)
- Create `duckdb_httplib::Client` with `proto_host_port_`
- Configure same SSL and timeout settings as `list_files()`
- Extract filename from `href` (last path component, URL-decoded)
- Construct local file path: `local_dir + "/" + filename` (use platform path separator)
- On Windows, also handle backslash paths
- Send HTTP GET request with Authorization header:
  ```
  duckdb_httplib::Headers headers = {
      {"Authorization", make_auth_header()}
  };
  auto res = client.Get(href, headers);
  ```
- Check response: 200 = success, 401 = auth error, 404 = file not found, other = generic error
- On success, write `res->body` to the local file path using standard C++ file I/O (`std::ofstream` in binary mode)
- Return `WebDavDownloadResult{true, "", local_path}` on success
- Return `WebDavDownloadResult{false, error_description, ""}` on any failure

**2. Add a helper function for temp directory creation:**

Add a free function in the header and implementation:

```cpp
// Create a temporary directory for downloads. Returns the path.
// On Windows: uses GetTempPathW + a unique subdirectory name
// Cross-platform fallback: uses std::filesystem::temp_directory_path() if available
std::string create_temp_download_dir();
```

Implementation:
- Use `std::tmpnam` or platform APIs to get a temp path
- Create a subdirectory named `gdpdu_webdav_XXXXXX` (with random suffix for uniqueness)
- On Windows, use `_mkdir` or `CreateDirectoryA`
- Return the full path to the created directory
- If directory creation fails, return empty string (caller checks)

Also add:
```cpp
// Remove a temporary directory and all its contents
void cleanup_temp_dir(const std::string& dir_path);
```

This removes downloaded files and the temp directory after import is complete (used by Phase 8).

**3. Update `src/CMakeLists.txt`:**

Add `webdav_client.cpp` to the `EXTENSION_SOURCES` list:

```cmake
set(EXTENSION_SOURCES
    gdpdu_extension.cpp
    gdpdu_schema.cpp
    gdpdu_parser.cpp
    gdpdu_table_creator.cpp
    gdpdu_data_parser.cpp
    gdpdu_importer.cpp
    gdpdu_exporter.cpp
    xml_parser_factory.cpp
    xml_parser_registration.cpp
    generic_xml_parser.cpp
    gdpdu_xml_parser.cpp
    generic_xml_importer.cpp
    folder_importer.cpp
    webdav_client.cpp
)
```

No additional library linking needed — httplib.hpp is header-only and already available through DuckDB's include paths. pugixml is already linked.

**4. Verify httplib.hpp include path:**

DuckDB makes httplib available at `third_party/httplib/httplib.hpp`. The include should work as `#include "httplib.hpp"` since DuckDB's build system adds the third_party paths. If not, may need to use the full path or add an include directory. Check the DuckDB build configuration to confirm.

If direct `#include "httplib.hpp"` doesn't work, alternatives:
- `#include "duckdb/third_party/httplib/httplib.hpp"` — unlikely to work
- Add `target_include_directories` for the httplib path in CMakeLists.txt

The safest approach: check if `DISABLE_DUCKDB_REMOTE_INSTALL` and `DUCKDB_DISABLE_EXTENSION_LOAD` macros affect availability. The httplib inclusion in DuckDB is guarded by these. If needed, define `CPPHTTPLIB_OPENSSL_SUPPORT` for HTTPS support. Nextcloud typically uses HTTPS, so SSL support is important.

**Fallback approach if httplib is not accessible from extension code:**
Use the WinHTTP API on Windows (available via `#include <winhttp.h>`, link against `winhttp.lib`). This is always available on Windows and supports HTTPS natively. However, this would make the code Windows-only. Since the project's primary platform is Windows (per constraints), this is acceptable as a fallback. If this route is taken, add `target_link_libraries(gdpdu_loadable_extension winhttp)` to CMakeLists.txt.

**Implementation priority:** Try httplib first. If include/linking issues arise, fall back to WinHTTP.
  </action>
  <verify>
Run CMake configure to verify the new source file is picked up:
```
cd C:\gdpdu\build_new
cmake .. -G "Visual Studio 17 2022" -A x64
```
Verify no CMake errors. Check that `webdav_client.cpp` appears in the generated project files.

Verify the code structure: `webdav_client.hpp` exports WebDavClient class with list_files() and download_file() methods, plus create_temp_download_dir() and cleanup_temp_dir() utilities.
  </verify>
  <done>
`download_file()` downloads a file from WebDAV to a local temp directory via HTTP GET with Basic Auth. `create_temp_download_dir()` creates a unique temporary directory for downloads. `cleanup_temp_dir()` removes temp files after use. `webdav_client.cpp` is added to the CMake build. The complete WebDAV client module satisfies NET-01 (auth), NET-02 (list .zip files), and NET-03 (download to temp dir).
  </done>
</task>

</tasks>

<verification>
1. `src/include/webdav_client.hpp` exists and defines: WebDavClient, WebDavFile, WebDavResult, WebDavDownloadResult
2. `src/webdav_client.cpp` exists and implements: PROPFIND listing, GET download, base64 auth, XML parsing, temp dir management
3. `src/CMakeLists.txt` includes `webdav_client.cpp` in EXTENSION_SOURCES
4. CMake configure completes without errors
5. No exceptions thrown from WebDavClient methods — all errors returned via result structs
6. Code handles: auth failure (401), connection error, timeout, file not found (404), invalid XML response
</verification>

<success_criteria>
- WebDavClient class can be instantiated with a Nextcloud URL, username, and password
- list_files() sends PROPFIND and parses response to return .zip file list
- download_file() downloads a file to a local directory via GET
- create_temp_download_dir() creates a unique temp directory
- cleanup_temp_dir() removes temp directory and contents
- All error conditions return descriptive messages (no thrown exceptions)
- Build system compiles the new module without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-webdav-client/06-01-SUMMARY.md`
</output>
