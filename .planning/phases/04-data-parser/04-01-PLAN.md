# Plan: 04-01 — Data Parser Module

---
phase: 4
plan: 1
type: implementation
estimated_scope: medium
truths:
  - TableDef contains decimal_symbol, digit_grouping, is_utf8 from Phase 2 parsing
  - Data files are semicolon-delimited with optional quoting
  - German format uses comma for decimals and dot for thousands
  - Dates in DD.MM.YYYY format
key_links:
  - src/include/gdpdu_schema.hpp (TableDef, ColumnDef definitions)
  - src/gdpdu_table_creator.cpp (creates tables that data will populate)
artifacts:
  - src/include/gdpdu_data_parser.hpp (parser interface)
  - src/gdpdu_data_parser.cpp (implementation)
---

## Objective

Implement a data parser module that reads GDPdU `.txt` data files with German locale formatting (semicolon delimiters, comma decimals, DD.MM.YYYY dates) and converts field values to appropriate DuckDB types.

## Requirements Addressed

| REQ-ID | Description |
|--------|-------------|
| DATA-01 | Extension reads semicolon-delimited `.txt` files |
| DATA-02 | German decimal format is parsed (comma as decimal separator) |
| DATA-03 | German digit grouping is handled (dot as thousands separator) |
| DATA-04 | German date format is parsed (DD.MM.YYYY) |
| DATA-05 | UTF-8 encoded files are read correctly |
| DATA-06 | Quoted string values are parsed correctly |

## Context

### Data Format Analysis

From sample files (`Sachposten.txt`, `Debitor.txt`, `Land.txt`):

```
112261;"0027";01.06.2024;"Rechnung";"ELO0000050335";"05/2024 webshop Entwicklung";"SKS-K074350";45.967,50;"9008"...
```

**Format characteristics:**
- **Delimiter**: Semicolon (`;`)
- **Quote character**: Double quote (`"`) for strings
- **Decimal**: Comma (`,`) — e.g., `45.967,50` = 45967.50
- **Thousands**: Dot (`.`) — e.g., `45.967,50` has thousands separator
- **Date**: `DD.MM.YYYY` — e.g., `01.06.2024` = 2024-06-01
- **Empty values**: `""` or empty between semicolons
- **Encoding**: UTF-8 with German characters (Ö, ü, ä, ß)

### Existing Schema Support

`TableDef` in `gdpdu_schema.hpp` already has:
- `is_utf8` — from `<UTF8 />` element
- `decimal_symbol` — from `<DecimalSymbol>` (default `,`)
- `digit_grouping` — from `<DigitGroupingSymbol>` (default `.`)
- `columns` — ordered `ColumnDef` with `name`, `type`, `precision`

## Tasks

### Task 1: Create data parser header

**File**: `src/include/gdpdu_data_parser.hpp`

Define interface for parsing data files:

```cpp
#pragma once
#include "gdpdu_schema.hpp"
#include <string>
#include <vector>
#include <fstream>

namespace duckdb {

// Result of parsing a single data file
struct DataParseResult {
    std::string table_name;
    std::string file_path;
    int64_t rows_parsed;
    bool success;
    std::string error_message;
    
    DataParseResult() : rows_parsed(0), success(false) {}
};

// Parsed row - vector of string values (conversion happens at insert time)
using ParsedRow = std::vector<std::string>;

// Data parser class
class GdpduDataParser {
public:
    // Parse a single line into fields
    static std::vector<std::string> parse_line(
        const std::string& line,
        char delimiter = ';',
        char quote_char = '"'
    );
    
    // Convert German decimal to standard format
    // "45.967,50" -> "45967.50"
    static std::string convert_german_decimal(
        const std::string& value,
        char decimal_symbol = ',',
        char digit_grouping = '.'
    );
    
    // Convert German date to ISO format
    // "01.06.2024" -> "2024-06-01"
    static std::string convert_german_date(const std::string& value);
    
    // Convert a field value based on column type
    static std::string convert_field(
        const std::string& value,
        const ColumnDef& column,
        const TableDef& table
    );
    
    // Parse entire file and return rows
    static std::vector<ParsedRow> parse_file(
        const std::string& file_path,
        const TableDef& table,
        DataParseResult& result
    );
};

} // namespace duckdb
```

**Checkpoint**: Header compiles when included in test file

---

### Task 2: Implement line parser with quoted field handling

**File**: `src/gdpdu_data_parser.cpp`

Implement `parse_line()` for semicolon-delimited, quoted CSV:

```cpp
std::vector<std::string> GdpduDataParser::parse_line(
    const std::string& line,
    char delimiter,
    char quote_char
) {
    std::vector<std::string> fields;
    std::string current_field;
    bool in_quotes = false;
    
    for (size_t i = 0; i < line.size(); ++i) {
        char c = line[i];
        
        if (in_quotes) {
            if (c == quote_char) {
                // Check for escaped quote
                if (i + 1 < line.size() && line[i + 1] == quote_char) {
                    current_field += quote_char;
                    ++i; // Skip next quote
                } else {
                    in_quotes = false;
                }
            } else {
                current_field += c;
            }
        } else {
            if (c == quote_char) {
                in_quotes = true;
            } else if (c == delimiter) {
                fields.push_back(current_field);
                current_field.clear();
            } else {
                current_field += c;
            }
        }
    }
    
    // Don't forget last field
    fields.push_back(current_field);
    
    return fields;
}
```

**Test cases** (mental model):
- `"a";"b";"c"` → `["a", "b", "c"]`
- `"hello;world";"test"` → `["hello;world", "test"]`
- `"";"";""` → `["", "", ""]`
- `1;2;3` → `["1", "2", "3"]`
- `"a""b";"c"` → `["a\"b", "c"]` (escaped quote)

**Checkpoint**: `parse_line` correctly splits sample data lines

---

### Task 3: Implement German decimal conversion

**File**: `src/gdpdu_data_parser.cpp`

Convert German number format to standard:

```cpp
std::string GdpduDataParser::convert_german_decimal(
    const std::string& value,
    char decimal_symbol,
    char digit_grouping
) {
    if (value.empty()) {
        return value;
    }
    
    std::string result;
    result.reserve(value.size());
    
    for (char c : value) {
        if (c == digit_grouping) {
            // Skip thousands separator
            continue;
        } else if (c == decimal_symbol) {
            // Convert decimal separator to dot
            result += '.';
        } else {
            result += c;
        }
    }
    
    return result;
}
```

**Test cases**:
- `"45.967,50"` → `"45967.50"`
- `"-1.234,56"` → `"-1234.56"`
- `"100"` → `"100"` (no decimal)
- `""` → `""`
- `"0,00"` → `"0.00"`

**Checkpoint**: German decimals convert to standard format

---

### Task 4: Implement German date conversion

**File**: `src/gdpdu_data_parser.cpp`

Convert DD.MM.YYYY to YYYY-MM-DD:

```cpp
std::string GdpduDataParser::convert_german_date(const std::string& value) {
    if (value.empty()) {
        return value;
    }
    
    // Expected format: DD.MM.YYYY (10 chars)
    if (value.size() != 10 || value[2] != '.' || value[5] != '.') {
        // Return as-is if not in expected format
        return value;
    }
    
    // Extract parts
    std::string day = value.substr(0, 2);
    std::string month = value.substr(3, 2);
    std::string year = value.substr(6, 4);
    
    // Return ISO format
    return year + "-" + month + "-" + day;
}
```

**Test cases**:
- `"01.06.2024"` → `"2024-06-01"`
- `"31.12.2023"` → `"2023-12-31"`
- `""` → `""`
- `"invalid"` → `"invalid"` (pass-through)

**Checkpoint**: German dates convert to ISO format

---

### Task 5: Implement field converter

**File**: `src/gdpdu_data_parser.cpp`

Convert field based on column type:

```cpp
std::string GdpduDataParser::convert_field(
    const std::string& value,
    const ColumnDef& column,
    const TableDef& table
) {
    if (value.empty()) {
        return value;
    }
    
    switch (column.type) {
        case GdpduType::Numeric:
            return convert_german_decimal(value, table.decimal_symbol, table.digit_grouping);
            
        case GdpduType::Date:
            return convert_german_date(value);
            
        case GdpduType::AlphaNumeric:
        default:
            return value; // No conversion needed
    }
}
```

**Checkpoint**: Field converter routes to correct conversion function

---

### Task 6: Implement file parser

**File**: `src/gdpdu_data_parser.cpp`

Parse entire data file:

```cpp
std::vector<ParsedRow> GdpduDataParser::parse_file(
    const std::string& file_path,
    const TableDef& table,
    DataParseResult& result
) {
    std::vector<ParsedRow> rows;
    result.table_name = table.name;
    result.file_path = file_path;
    
    std::ifstream file(file_path);
    if (!file.is_open()) {
        result.success = false;
        result.error_message = "Failed to open file: " + file_path;
        return rows;
    }
    
    std::string line;
    int64_t line_number = 0;
    
    while (std::getline(file, line)) {
        ++line_number;
        
        // Skip empty lines
        if (line.empty()) {
            continue;
        }
        
        // Handle Windows line endings
        if (!line.empty() && line.back() == '\r') {
            line.pop_back();
        }
        
        // Parse line into fields
        auto fields = parse_line(line);
        
        // Validate field count
        if (fields.size() != table.columns.size()) {
            result.success = false;
            result.error_message = "Line " + std::to_string(line_number) + 
                ": expected " + std::to_string(table.columns.size()) + 
                " fields, got " + std::to_string(fields.size());
            return rows;
        }
        
        // Convert each field based on column type
        ParsedRow row;
        row.reserve(fields.size());
        
        for (size_t i = 0; i < fields.size(); ++i) {
            row.push_back(convert_field(fields[i], table.columns[i], table));
        }
        
        rows.push_back(std::move(row));
    }
    
    result.rows_parsed = static_cast<int64_t>(rows.size());
    result.success = true;
    
    return rows;
}
```

**Checkpoint**: File parser reads all rows from sample data file

---

### Task 7: Update CMakeLists.txt

**File**: `src/CMakeLists.txt`

Add new source file to build:

```cmake
set(EXTENSION_SOURCES
    gdpdu_extension.cpp
    gdpdu_schema.cpp
    gdpdu_table_creator.cpp
    gdpdu_data_parser.cpp
)
```

**Checkpoint**: Extension compiles with data parser module

---

### Task 8: Manual verification with sample data

Verify the parser works with actual GDPdU data:

1. Create a test that:
   - Uses a pre-built TableDef matching `Land.txt` schema
   - Parses `Land.txt` 
   - Verifies row count (135 rows)
   - Verifies first row values

2. Test with `Sachposten.txt`:
   - Has numeric values with German formatting
   - Has date values
   - Verify decimal conversion (45.967,50 → 45967.50)
   - Verify date conversion (01.06.2024 → 2024-06-01)

**Checkpoint**: Parser correctly handles real GDPdU data files

---

## Verification

### Automated Checks

- [ ] Extension compiles without errors
- [ ] All new functions compile and link

### Manual Verification

Run these checks after implementation:

```
1. Line parsing test:
   Input: "112261;\"0027\";01.06.2024;\"Rechnung\""
   Expected: ["112261", "0027", "01.06.2024", "Rechnung"]

2. German decimal test:
   Input: "45.967,50"
   Expected: "45967.50"

3. German date test:
   Input: "01.06.2024"
   Expected: "2024-06-01"

4. File parse test (Land.txt):
   Expected: 135 rows parsed successfully
```

## Success Criteria

1. `parse_line()` correctly splits semicolon-delimited lines with quoted fields
2. German decimals (`45.967,50`) convert to `45967.50`
3. German dates (`DD.MM.YYYY`) convert to `YYYY-MM-DD`
4. `parse_file()` reads UTF-8 files and returns converted rows
5. Field count validation catches malformed rows
6. Extension compiles and links with new module

## Output

After completing this plan:
- `src/include/gdpdu_data_parser.hpp` — parser interface
- `src/gdpdu_data_parser.cpp` — implementation
- Updated `src/CMakeLists.txt` with new source file
- Parser module ready for integration in Phase 5

## Next Steps

After this plan completes:
1. Phase 5 will integrate parser with table creator
2. Phase 5 will use `parse_file()` to get rows, then INSERT into created tables
3. Final `gdpdu_import()` table function will orchestrate: parse XML → create tables → parse data → insert rows
